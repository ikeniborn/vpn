"""
Tests for Pydantic models.
"""

from datetime import datetime, timedelta
from uuid import uuid4

import pytest
from pydantic import ValidationError

from vpn.core.models import (
    CryptoKeys,
    ProtocolConfig,
    ProtocolType,
    TrafficStats,
    User,
    UserStatus,
    ServerConfig,
    DockerConfig,
    FirewallRule,
    ServerStatus,
)


class TestTrafficStats:
    """Test TrafficStats model."""
    
    def test_default_values(self):
        """Test default values."""
        stats = TrafficStats()
        assert stats.upload_bytes == 0
        assert stats.download_bytes == 0
        assert stats.total_bytes == 0
        assert isinstance(stats.last_reset, datetime)
    
    def test_mb_properties(self):
        """Test megabyte conversion properties."""
        stats = TrafficStats(
            upload_bytes=1024 * 1024 * 10,  # 10 MB
            download_bytes=1024 * 1024 * 20,  # 20 MB
            total_bytes=1024 * 1024 * 30,  # 30 MB
        )
        assert stats.upload_mb == 10.0
        assert stats.download_mb == 20.0
        assert stats.total_mb == 30.0


class TestCryptoKeys:
    """Test CryptoKeys model."""
    
    def test_default_uuid(self):
        """Test UUID is generated by default."""
        keys = CryptoKeys()
        assert keys.uuid is not None
        assert len(keys.uuid) == 36  # Standard UUID string length
    
    def test_all_fields(self):
        """Test all fields can be set."""
        keys = CryptoKeys(
            private_key="private_test",
            public_key="public_test",
            short_id="short_test",
            uuid="custom-uuid",
            password="password123"
        )
        assert keys.private_key == "private_test"
        assert keys.public_key == "public_test"
        assert keys.short_id == "short_test"
        assert keys.uuid == "custom-uuid"
        assert keys.password == "password123"


class TestProtocolConfig:
    """Test ProtocolConfig model."""
    
    def test_vless_config(self):
        """Test VLESS protocol configuration."""
        config = ProtocolConfig(
            type=ProtocolType.VLESS,
            flow="xtls-rprx-vision",
            encryption="none",
            reality_enabled=True,
            reality_public_key="test_public_key",
            reality_short_id="test_short_id"
        )
        assert config.type == ProtocolType.VLESS
        assert config.flow == "xtls-rprx-vision"
        assert config.reality_enabled is True
    
    def test_shadowsocks_config(self):
        """Test Shadowsocks protocol configuration."""
        config = ProtocolConfig(
            type=ProtocolType.SHADOWSOCKS,
            method="aes-256-gcm"
        )
        assert config.type == ProtocolType.SHADOWSOCKS
        assert config.method == "aes-256-gcm"
    
    def test_proxy_config(self):
        """Test proxy protocol configuration."""
        config = ProtocolConfig(
            type=ProtocolType.HTTP,
            auth_required=True,
            rate_limit=1024 * 1024,  # 1 MB/s
            connection_limit=100
        )
        assert config.type == ProtocolType.HTTP
        assert config.auth_required is True
        assert config.rate_limit == 1024 * 1024
        assert config.connection_limit == 100


class TestUser:
    """Test User model."""
    
    def test_minimal_user(self):
        """Test creating user with minimal fields."""
        protocol = ProtocolConfig(type=ProtocolType.VLESS)
        user = User(username="testuser", protocol=protocol)
        
        assert user.username == "testuser"
        assert user.status == UserStatus.ACTIVE
        assert isinstance(user.id, uuid4().__class__)
        assert isinstance(user.keys, CryptoKeys)
        assert isinstance(user.traffic, TrafficStats)
    
    def test_username_validation(self):
        """Test username validation."""
        protocol = ProtocolConfig(type=ProtocolType.VLESS)
        
        # Valid usernames
        user1 = User(username="test_user", protocol=protocol)
        assert user1.username == "test_user"
        
        user2 = User(username="Test-User", protocol=protocol)
        assert user2.username == "test-user"  # Converted to lowercase
        
        # Invalid usernames
        with pytest.raises(ValidationError):
            User(username="ab", protocol=protocol)  # Too short
        
        with pytest.raises(ValidationError):
            User(username="test@user", protocol=protocol)  # Invalid character
    
    def test_email_validation(self):
        """Test email validation."""
        protocol = ProtocolConfig(type=ProtocolType.VLESS)
        
        # Valid email
        user = User(username="test", email="Test@Example.com", protocol=protocol)
        assert user.email == "test@example.com"  # Converted to lowercase
        
        # Invalid emails
        with pytest.raises(ValidationError):
            User(username="test", email="invalid", protocol=protocol)
        
        with pytest.raises(ValidationError):
            User(username="test", email="@example.com", protocol=protocol)
    
    def test_is_active_property(self):
        """Test is_active property."""
        protocol = ProtocolConfig(type=ProtocolType.VLESS)
        
        # Active user
        user = User(username="test", protocol=protocol)
        assert user.is_active is True
        
        # Inactive user
        user.status = UserStatus.INACTIVE
        assert user.is_active is False
        
        # Expired user
        user.status = UserStatus.ACTIVE
        user.expires_at = datetime.utcnow() - timedelta(days=1)
        assert user.is_active is False


class TestServerConfig:
    """Test ServerConfig model."""
    
    def test_minimal_server(self):
        """Test creating server with minimal fields."""
        docker_config = DockerConfig(image="vpn/server")
        protocol = ProtocolConfig(type=ProtocolType.VLESS)
        
        server = ServerConfig(
            name="test-server",
            protocol=protocol,
            port=8443,
            docker_config=docker_config
        )
        
        assert server.name == "test-server"
        assert server.port == 8443
        assert server.status == ServerStatus.STOPPED
        assert server.auto_start is True
    
    def test_port_validation(self):
        """Test port validation."""
        docker_config = DockerConfig(image="vpn/server")
        protocol = ProtocolConfig(type=ProtocolType.VLESS)
        
        # Valid port
        server = ServerConfig(
            name="test",
            protocol=protocol,
            port=8443,
            docker_config=docker_config
        )
        assert server.port == 8443
        
        # Invalid port (well-known)
        with pytest.raises(ValidationError):
            ServerConfig(
                name="test",
                protocol=protocol,
                port=80,
                docker_config=docker_config
            )
        
        # Invalid port (out of range)
        with pytest.raises(ValidationError):
            ServerConfig(
                name="test",
                protocol=protocol,
                port=70000,
                docker_config=docker_config
            )


class TestFirewallRule:
    """Test FirewallRule model."""
    
    def test_default_values(self):
        """Test default values."""
        rule = FirewallRule(port=8443)
        assert rule.protocol == "tcp"
        assert rule.port == 8443
        assert rule.action == "allow"
        assert rule.source is None
    
    def test_all_fields(self):
        """Test all fields."""
        rule = FirewallRule(
            protocol="both",
            port=9000,
            source="192.168.1.0/24",
            action="deny",
            comment="Block local network"
        )
        assert rule.protocol == "both"
        assert rule.port == 9000
        assert rule.source == "192.168.1.0/24"
        assert rule.action == "deny"
        assert rule.comment == "Block local network"


class TestProtocolTypeEnum:
    """Test ProtocolType enum."""
    
    def test_valid_protocols(self):
        """Test all valid protocol types."""
        assert ProtocolType.VLESS.value == "vless"
        assert ProtocolType.SHADOWSOCKS.value == "shadowsocks"
        assert ProtocolType.WIREGUARD.value == "wireguard"
        assert ProtocolType.HTTP.value == "http"
        assert ProtocolType.SOCKS5.value == "socks5"
    
    def test_protocol_from_string(self):
        """Test creating protocol from string."""
        assert ProtocolType("vless") == ProtocolType.VLESS
        assert ProtocolType("shadowsocks") == ProtocolType.SHADOWSOCKS
        assert ProtocolType("wireguard") == ProtocolType.WIREGUARD


class TestUserStatusEnum:
    """Test UserStatus enum."""
    
    def test_valid_statuses(self):
        """Test all valid user statuses."""
        assert UserStatus.ACTIVE.value == "active"
        assert UserStatus.INACTIVE.value == "inactive"
        assert UserStatus.SUSPENDED.value == "suspended"


class TestServerStatusEnum:
    """Test ServerStatus enum."""
    
    def test_valid_statuses(self):
        """Test all valid server statuses."""
        assert ServerStatus.RUNNING.value == "running"
        assert ServerStatus.STOPPED.value == "stopped"
        assert ServerStatus.STARTING.value == "starting"
        assert ServerStatus.STOPPING.value == "stopping"
        assert ServerStatus.ERROR.value == "error"


class TestModelEdgeCases:
    """Test edge cases and error conditions."""
    
    def test_user_with_all_fields(self):
        """Test user with all possible fields."""
        protocol = ProtocolConfig(type=ProtocolType.VLESS)
        keys = CryptoKeys(
            private_key="test_private",
            public_key="test_public",
            short_id="test_short"
        )
        traffic = TrafficStats(
            upload_bytes=1024,
            download_bytes=2048,
            total_bytes=3072
        )
        
        user = User(
            username="full_user",
            email="test@example.com",
            status=UserStatus.ACTIVE,
            protocol=protocol,
            keys=keys,
            traffic=traffic,
            expires_at=datetime.utcnow() + timedelta(days=30),
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow()
        )
        
        assert user.username == "full_user"
        assert user.email == "test@example.com"
        assert user.is_active is True
        assert user.keys.private_key == "test_private"
        assert user.traffic.total_bytes == 3072
    
    def test_traffic_stats_calculations(self):
        """Test traffic statistics calculations."""
        stats = TrafficStats(
            upload_bytes=1_000_000,  # 1 MB
            download_bytes=2_000_000  # 2 MB
        )
        
        # Auto-calculated total
        assert stats.total_bytes == 3_000_000
        assert abs(stats.upload_mb - 0.95) < 0.1  # ~0.95 MB
        assert abs(stats.download_mb - 1.91) < 0.1  # ~1.91 MB
        assert abs(stats.total_mb - 2.86) < 0.1  # ~2.86 MB
    
    def test_protocol_config_extra_fields(self):
        """Test protocol config with extra fields."""
        config = ProtocolConfig(
            type=ProtocolType.VLESS,
            transport="tcp",
            security="reality",
            extra_config={
                "reality": {
                    "dest": "www.google.com:443",
                    "server_names": ["www.google.com"],
                    "fingerprint": "chrome"
                }
            }
        )
        
        assert config.type == ProtocolType.VLESS
        assert config.transport == "tcp"
        assert config.security == "reality"
        assert "reality" in config.extra_config
    
    def test_server_config_with_custom_paths(self):
        """Test server config with custom paths."""
        from pathlib import Path
        
        docker_config = DockerConfig(image="test/image")
        protocol = ProtocolConfig(type=ProtocolType.VLESS)
        
        server = ServerConfig(
            name="custom-server",
            protocol=protocol,
            port=9443,
            docker_config=docker_config,
            config_path=Path("/custom/config"),
            data_path=Path("/custom/data"),
            log_path=Path("/custom/logs")
        )
        
        assert server.config_path == Path("/custom/config")
        assert server.data_path == Path("/custom/data")
        assert server.log_path == Path("/custom/logs")
    
    def test_user_expiration_edge_cases(self):
        """Test user expiration edge cases."""
        protocol = ProtocolConfig(type=ProtocolType.VLESS)
        
        # User expires in 1 second
        user = User(
            username="expiring",
            protocol=protocol,
            expires_at=datetime.utcnow() + timedelta(seconds=1)
        )
        assert user.is_active is True
        
        # User expired 1 second ago
        user.expires_at = datetime.utcnow() - timedelta(seconds=1)
        assert user.is_active is False
    
    def test_invalid_email_formats(self):
        """Test various invalid email formats."""
        protocol = ProtocolConfig(type=ProtocolType.VLESS)
        
        invalid_emails = [
            "plainaddress",
            "@missingtoplevel.org",
            "missing@.org",
            "missing@domain",
            "spaces in@email.com",
            "email@",
            "",
            "email@domain.",
            "email..double.dot@domain.com",
        ]
        
        for invalid_email in invalid_emails:
            with pytest.raises(ValidationError):
                User(username="test", email=invalid_email, protocol=protocol)
    
    def test_invalid_usernames(self):
        """Test various invalid username formats."""
        protocol = ProtocolConfig(type=ProtocolType.VLESS)
        
        invalid_usernames = [
            "",  # Empty
            "ab",  # Too short
            "a" * 51,  # Too long
            "user@name",  # Invalid character
            "user name",  # Space
            "user.name.",  # Ends with dot
            ".username",  # Starts with dot
            "user..name",  # Double dots
            "123",  # Only numbers
            "-username",  # Starts with dash
            "username-",  # Ends with dash
        ]
        
        for invalid_username in invalid_usernames:
            with pytest.raises(ValidationError):
                User(username=invalid_username, protocol=protocol)
    
    def test_port_boundary_values(self):
        """Test port validation boundary values."""
        docker_config = DockerConfig(image="test/image")
        protocol = ProtocolConfig(type=ProtocolType.VLESS)
        
        # Valid boundary ports
        valid_ports = [1024, 8080, 65535]
        for port in valid_ports:
            server = ServerConfig(
                name=f"test-{port}",
                protocol=protocol,
                port=port,
                docker_config=docker_config
            )
            assert server.port == port
        
        # Invalid boundary ports
        invalid_ports = [0, 1, 22, 80, 443, 65536, 70000]
        for port in invalid_ports:
            with pytest.raises(ValidationError):
                ServerConfig(
                    name=f"test-{port}",
                    protocol=protocol,
                    port=port,
                    docker_config=docker_config
                )


class TestModelSerialization:
    """Test model serialization and deserialization."""
    
    def test_user_json_serialization(self):
        """Test user model JSON serialization."""
        protocol = ProtocolConfig(type=ProtocolType.VLESS)
        user = User(username="testuser", protocol=protocol)
        
        # Serialize to JSON
        json_data = user.model_dump()
        assert "id" in json_data
        assert json_data["username"] == "testuser"
        assert json_data["status"] == "active"
        
        # Deserialize from JSON
        new_user = User.model_validate(json_data)
        assert new_user.username == user.username
        assert new_user.id == user.id
        assert new_user.status == user.status
    
    def test_server_config_json_serialization(self):
        """Test server config JSON serialization."""
        docker_config = DockerConfig(image="test/image")
        protocol = ProtocolConfig(type=ProtocolType.VLESS)
        server = ServerConfig(
            name="test-server",
            protocol=protocol,
            port=8443,
            docker_config=docker_config
        )
        
        # Serialize to JSON
        json_data = server.model_dump()
        assert json_data["name"] == "test-server"
        assert json_data["port"] == 8443
        
        # Deserialize from JSON
        new_server = ServerConfig.model_validate(json_data)
        assert new_server.name == server.name
        assert new_server.port == server.port
    
    def test_protocol_config_with_nested_data(self):
        """Test protocol config with nested extra_config."""
        config = ProtocolConfig(
            type=ProtocolType.VLESS,
            extra_config={
                "reality": {
                    "dest": "www.google.com:443",
                    "server_names": ["www.google.com", "www.youtube.com"],
                    "private_key": "test_private_key",
                    "short_ids": ["", "0123456789abcdef"]
                },
                "transport": {
                    "type": "tcp",
                    "header": {"type": "none"}
                }
            }
        )
        
        # Serialize and deserialize
        json_data = config.model_dump()
        new_config = ProtocolConfig.model_validate(json_data)
        
        assert new_config.type == ProtocolType.VLESS
        assert new_config.extra_config["reality"]["dest"] == "www.google.com:443"
        assert len(new_config.extra_config["reality"]["server_names"]) == 2


class TestModelValidation:
    """Test advanced model validation scenarios."""
    
    def test_conditional_validation(self):
        """Test validation that depends on other fields."""
        # VLESS with Reality should have specific fields
        vless_config = ProtocolConfig(
            type=ProtocolType.VLESS,
            reality_enabled=True,
            reality_public_key="test_key",
            reality_short_id="test_id"
        )
        assert vless_config.reality_enabled is True
        
        # Shadowsocks should have method
        ss_config = ProtocolConfig(
            type=ProtocolType.SHADOWSOCKS,
            method="aes-256-gcm"
        )
        assert ss_config.method == "aes-256-gcm"
    
    def test_traffic_stats_consistency(self):
        """Test traffic stats internal consistency."""
        # Total should be sum of upload and download
        stats = TrafficStats(upload_bytes=1000, download_bytes=2000)
        assert stats.total_bytes == 3000
        
        # Manual total should be overridden
        stats = TrafficStats(
            upload_bytes=1000,
            download_bytes=2000,
            total_bytes=5000  # This should be ignored
        )
        assert stats.total_bytes == 3000  # Auto-calculated
    
    def test_datetime_field_validation(self):
        """Test datetime field validation."""
        protocol = ProtocolConfig(type=ProtocolType.VLESS)
        now = datetime.utcnow()
        
        # Valid datetime
        user = User(
            username="test",
            protocol=protocol,
            created_at=now,
            expires_at=now + timedelta(days=30)
        )
        assert user.created_at == now
        assert user.expires_at > user.created_at