//! Secret resource generation

use crate::{
    crd::{VpnServer, VpnProtocol},
    error::Result,
    resources::{common_labels, common_annotations, owner_reference},
};
use k8s_openapi::{
    api::core::v1::Secret,
    apimachinery::pkg::apis::meta::v1::ObjectMeta,
    ByteString,
};
use kube::ResourceExt;
use std::collections::BTreeMap;

/// Create Secret for VPN server keys and credentials
pub fn create_vpn_secret(vpn: &VpnServer) -> Result<Secret> {
    let name = format!("{}-secret", vpn.name_any());
    let namespace = vpn.namespace().unwrap_or_default();
    
    let mut data = BTreeMap::new();
    
    // Generate protocol-specific secrets
    match &vpn.spec.protocol {
        VpnProtocol::Vless => {
            // Generate VLESS UUID
            let uuid = uuid::Uuid::new_v4().to_string();
            data.insert("uuid".to_string(), ByteString(uuid.into_bytes()));
            
            // Generate Reality keys if TLS is enabled
            if vpn.spec.security.enable_tls {
                let private_key = generate_random_key(32);
                let public_key = derive_public_key(&private_key);
                data.insert("reality_private_key".to_string(), ByteString(private_key));
                data.insert("reality_public_key".to_string(), ByteString(public_key));
            }
        }
        VpnProtocol::Outline => {
            // Generate Shadowsocks password
            let password = generate_random_password(32);
            data.insert("password".to_string(), ByteString(password.into_bytes()));
        }
        VpnProtocol::Wireguard => {
            // Generate WireGuard keys
            let private_key = generate_random_key(32);
            let public_key = derive_public_key(&private_key);
            data.insert("private_key".to_string(), ByteString(private_key));
            data.insert("public_key".to_string(), ByteString(public_key));
        }
        VpnProtocol::OpenVPN => {
            // OpenVPN certificates would be generated by a separate process
            // For now, just create placeholders
            data.insert("ca_cert".to_string(), ByteString(b"CA_CERT_PLACEHOLDER".to_vec()));
            data.insert("server_cert".to_string(), ByteString(b"SERVER_CERT_PLACEHOLDER".to_vec()));
            data.insert("server_key".to_string(), ByteString(b"SERVER_KEY_PLACEHOLDER".to_vec()));
            data.insert("dh_params".to_string(), ByteString(b"DH_PARAMS_PLACEHOLDER".to_vec()));
        }
    }
    
    // Add admin credentials
    let admin_password = generate_random_password(16);
    data.insert("admin_password".to_string(), ByteString(admin_password.into_bytes()));
    
    Ok(Secret {
        metadata: ObjectMeta {
            name: Some(name),
            namespace: Some(namespace),
            labels: Some(common_labels(vpn)),
            annotations: Some(common_annotations(vpn)),
            owner_references: Some(owner_reference(vpn)),
            ..Default::default()
        },
        data: Some(data),
        type_: Some("Opaque".to_string()),
        ..Default::default()
    })
}

/// Generate random key
fn generate_random_key(len: usize) -> Vec<u8> {
    use rand::Rng;
    let mut rng = rand::thread_rng();
    (0..len).map(|_| rng.gen::<u8>()).collect()
}

/// Generate random password
fn generate_random_password(len: usize) -> String {
    use rand::Rng;
    const CHARSET: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ\
                            abcdefghijklmnopqrstuvwxyz\
                            0123456789!@#$%^&*";
    let mut rng = rand::thread_rng();
    
    (0..len)
        .map(|_| {
            let idx = rng.gen_range(0..CHARSET.len());
            CHARSET[idx] as char
        })
        .collect()
}

/// Derive public key from private key (simplified)
fn derive_public_key(private_key: &[u8]) -> Vec<u8> {
    // In a real implementation, this would use proper cryptography
    // For now, just return a derived value
    use std::collections::hash_map::DefaultHasher;
    use std::hash::{Hash, Hasher};
    
    let mut hasher = DefaultHasher::new();
    private_key.hash(&mut hasher);
    let hash = hasher.finish();
    
    hash.to_be_bytes().to_vec()
}