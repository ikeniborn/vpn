#!/bin/bash

# =============================================================================
# Log Rotation Automation Module
# 
# This module provides automated log rotation for VPN services.
# Implements intelligent log management with compression and cleanup.
#
# Functions exported:
# - setup_log_rotation()
# - rotate_logs_now()
# - configure_logrotate()
# - cleanup_old_logs()
# - monitor_log_sizes()
#
# Dependencies: lib/common.sh
# =============================================================================

# Source required libraries
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="${PROJECT_ROOT:-$(cd "$SCRIPT_DIR/../.." && pwd)}"

source "$PROJECT_ROOT/lib/common.sh" 2>/dev/null || {
    echo "Error: Cannot source lib/common.sh"
    exit 1
}

# =============================================================================
# CONFIGURATION
# =============================================================================

# Default configuration
DEFAULT_MAX_SIZE="100M"
DEFAULT_ROTATE_COUNT="7"
DEFAULT_COMPRESS_AFTER="1"
DEFAULT_LOG_DIRS=(
    "/opt/v2ray/logs"
    "/opt/outline/logs"
    "/var/log/vpn"
    "/var/log"
)

# Logrotate configuration file
LOGROTATE_CONFIG="/etc/logrotate.d/vpn-logs"

# =============================================================================
# LOG ROTATION SETUP
# =============================================================================

# Setup comprehensive log rotation
setup_log_rotation() {
    local max_size="${1:-$DEFAULT_MAX_SIZE}"
    local rotate_count="${2:-$DEFAULT_ROTATE_COUNT}"
    local compress_after="${3:-$DEFAULT_COMPRESS_AFTER}"
    local debug=${4:-false}
    
    [ "$debug" = true ] && log "Setting up log rotation..."
    
    # Check if logrotate is installed
    if ! command -v logrotate >/dev/null 2>&1; then
        log "Installing logrotate..."
        if command -v apt-get >/dev/null 2>&1; then
            apt-get update && apt-get install -y logrotate
        elif command -v yum >/dev/null 2>&1; then
            yum install -y logrotate
        elif command -v dnf >/dev/null 2>&1; then
            dnf install -y logrotate
        else
            error "Could not install logrotate - package manager not found"
            return 1
        fi
    fi
    
    # Create VPN log rotation configuration
    configure_logrotate "$max_size" "$rotate_count" "$compress_after" "$debug"
    
    # Setup cron job for frequent rotation
    setup_log_rotation_cron "$debug"
    
    # Create log monitoring script
    create_log_monitor_script "$debug"
    
    success "Log rotation setup completed"
    return 0
}

# Configure logrotate for VPN logs
configure_logrotate() {
    local max_size="$1"
    local rotate_count="$2"
    local compress_after="$3"
    local debug=${4:-false}
    
    [ "$debug" = true ] && log "Configuring logrotate..."
    
    # Create comprehensive logrotate configuration
    cat > "$LOGROTATE_CONFIG" <<EOF
# VPN Log Rotation Configuration
# Generated by VPN Management System

# Xray/V2Ray logs
/opt/v2ray/logs/*.log {
    size $max_size
    rotate $rotate_count
    compress
    compresscmd /bin/gzip
    compressext .gz
    compressoptions -9
    delaycompress
    missingok
    notifempty
    create 644 root root
    sharedscripts
    postrotate
        # Signal Xray container to reopen log files
        if docker ps --format "{{.Names}}" | grep -q "xray"; then
            docker exec xray pkill -USR1 xray 2>/dev/null || true
        fi
    endscript
    # Compress after $compress_after rotations
    $([ "$compress_after" -gt 1 ] && echo "compresscmd /bin/gzip")
}

# Outline VPN logs
/opt/outline/logs/*.log {
    size $max_size
    rotate $rotate_count
    compress
    compresscmd /bin/gzip
    compressext .gz
    compressoptions -9
    delaycompress
    missingok
    notifempty
    create 644 root root
    sharedscripts
    postrotate
        # Signal Outline container to reopen log files
        if docker ps --format "{{.Names}}" | grep -q "shadowbox"; then
            docker exec shadowbox pkill -USR1 node 2>/dev/null || true
        fi
    endscript
}

# VPN management system logs
/var/log/vpn*.log {
    size $max_size
    rotate $rotate_count
    compress
    compresscmd /bin/gzip
    compressext .gz
    compressoptions -9
    delaycompress
    missingok
    notifempty
    create 644 root root
}

# Health check logs
/var/log/vpn-health-check.log {
    size 50M
    rotate 5
    compress
    compresscmd /bin/gzip
    compressext .gz
    compressoptions -9
    delaycompress
    missingok
    notifempty
    create 644 root root
    postrotate
        # Restart health check server if running
        if [ -f /var/run/vpn-health-check.pid ]; then
            pid=\$(cat /var/run/vpn-health-check.pid)
            if kill -0 "\$pid" 2>/dev/null; then
                kill -USR1 "\$pid" 2>/dev/null || true
            fi
        fi
    endscript
}

# Docker container logs (if using json-file driver)
/var/lib/docker/containers/*/*-json.log {
    size 100M
    rotate 3
    compress
    compresscmd /bin/gzip
    compressext .gz
    compressoptions -9
    delaycompress
    missingok
    notifempty
    create 644 root root
    # Only rotate VPN-related container logs
    tabooext + .bak .dpkg-dist .dpkg-old .rpm-save .rpm-new .tmp
}
EOF
    
    # Test logrotate configuration
    if logrotate -d "$LOGROTATE_CONFIG" >/dev/null 2>&1; then
        [ "$debug" = true ] && success "Logrotate configuration is valid"
    else
        error "Logrotate configuration test failed"
        return 1
    fi
    
    return 0
}

# =============================================================================
# CRON SETUP
# =============================================================================

# Setup cron job for log rotation
setup_log_rotation_cron() {
    local debug=${1:-false}
    
    [ "$debug" = true ] && log "Setting up log rotation cron job..."
    
    # Create hourly log check script
    local cron_script="/usr/local/bin/vpn-log-check"
    cat > "$cron_script" <<'EOF'
#!/bin/bash
# VPN Log Check Script - runs hourly

LOG_FILE="/var/log/vpn-log-rotation.log"
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

echo "[$TIMESTAMP] Starting log check..." >> "$LOG_FILE"

# Check log sizes and rotate if needed
for log_dir in /opt/v2ray/logs /opt/outline/logs /var/log; do
    if [ -d "$log_dir" ]; then
        find "$log_dir" -name "*.log" -size +50M 2>/dev/null | while read -r large_log; do
            echo "[$TIMESTAMP] Large log found: $large_log" >> "$LOG_FILE"
            # Force rotation for large logs
            /usr/sbin/logrotate -f /etc/logrotate.d/vpn-logs >> "$LOG_FILE" 2>&1
            break
        done
    fi
done

# Clean up old compressed logs (older than 30 days)
find /opt/v2ray/logs /opt/outline/logs /var/log -name "*.log.*.gz" -mtime +30 -delete 2>/dev/null || true

echo "[$TIMESTAMP] Log check completed." >> "$LOG_FILE"
EOF
    
    chmod +x "$cron_script"
    
    # Add to crontab (run every hour)
    local cron_entry="0 * * * * root $cron_script"
    
    # Check if entry already exists
    if ! crontab -l 2>/dev/null | grep -q "$cron_script"; then
        # Add to system crontab
        echo "$cron_entry" >> /etc/crontab
        [ "$debug" = true ] && log "Added hourly log rotation cron job"
    else
        [ "$debug" = true ] && log "Log rotation cron job already exists"
    fi
    
    # Also add to logrotate.d to run with daily logrotate
    if ! grep -q "vpn-logs" /etc/cron.daily/logrotate 2>/dev/null; then
        # Create daily logrotate script for VPN
        cat > /etc/cron.daily/vpn-logrotate <<'EOF'
#!/bin/bash
# Daily VPN log rotation

if [ -f /etc/logrotate.d/vpn-logs ]; then
    /usr/sbin/logrotate /etc/logrotate.d/vpn-logs
fi
EOF
        chmod +x /etc/cron.daily/vpn-logrotate
        [ "$debug" = true ] && log "Added daily VPN logrotate script"
    fi
    
    return 0
}

# =============================================================================
# LOG MONITORING
# =============================================================================

# Create log monitoring script
create_log_monitor_script() {
    local debug=${1:-false}
    
    [ "$debug" = true ] && log "Creating log monitoring script..."
    
    local monitor_script="/usr/local/bin/vpn-log-monitor"
    cat > "$monitor_script" <<'EOF'
#!/bin/bash
# VPN Log Monitor - checks log sizes and health

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
source "$PROJECT_ROOT/lib/common.sh" 2>/dev/null || {
    echo "Error: Cannot source common.sh"
    exit 1
}

# Configuration
MAX_LOG_SIZE_MB=100
ALERT_THRESHOLD_MB=80
LOG_DIRS=("/opt/v2ray/logs" "/opt/outline/logs" "/var/log")

# Function to convert size to MB
size_to_mb() {
    local size="$1"
    case "$size" in
        *K) echo "$size" | sed 's/K//' | awk '{print $1/1024}' ;;
        *M) echo "$size" | sed 's/M//' ;;
        *G) echo "$size" | sed 's/G//' | awk '{print $1*1024}' ;;
        *) echo "0" ;;
    esac
}

# Monitor log sizes
monitor_log_sizes() {
    local alerts=()
    local total_size=0
    
    echo "VPN Log Monitor Report - $(date)"
    echo "========================================"
    
    for log_dir in "${LOG_DIRS[@]}"; do
        if [ -d "$log_dir" ]; then
            echo ""
            echo "Directory: $log_dir"
            echo "------------------------"
            
            find "$log_dir" -name "*.log" -exec ls -lh {} \; 2>/dev/null | while read -r line; do
                local size=$(echo "$line" | awk '{print $5}')
                local file=$(echo "$line" | awk '{print $9}')
                local size_mb=$(size_to_mb "$size")
                
                echo "  $file: $size"
                
                # Check if file exceeds alert threshold
                if (( $(echo "$size_mb > $ALERT_THRESHOLD_MB" | bc -l) )); then
                    alerts+=("$file ($size)")
                fi
                
                total_size=$(echo "$total_size + $size_mb" | bc -l)
            done
        fi
    done
    
    echo ""
    echo "Summary:"
    echo "--------"
    echo "Total log size: $(printf "%.1f" "$total_size") MB"
    
    # Check for large logs
    if [ ${#alerts[@]} -gt 0 ]; then
        echo ""
        echo "ALERTS - Large log files:"
        for alert in "${alerts[@]}"; do
            echo "  ⚠️  $alert"
        done
        
        echo ""
        echo "Consider running: logrotate -f /etc/logrotate.d/vpn-logs"
        return 1
    else
        echo "✅ All log files are within normal size limits"
        return 0
    fi
}

# Monitor disk space
monitor_disk_space() {
    local log_partitions=$(df "${LOG_DIRS[@]}" 2>/dev/null | awk 'NR>1 {print $5 " " $6}' | sort -u)
    
    echo ""
    echo "Disk Space Check:"
    echo "-----------------"
    
    local space_alerts=()
    while read -r usage mountpoint; do
        local usage_percent=$(echo "$usage" | sed 's/%//')
        echo "  $mountpoint: $usage used"
        
        if [ "$usage_percent" -gt 85 ]; then
            space_alerts+=("$mountpoint ($usage used)")
        fi
    done <<< "$log_partitions"
    
    if [ ${#space_alerts[@]} -gt 0 ]; then
        echo ""
        echo "ALERTS - High disk usage:"
        for alert in "${space_alerts[@]}"; do
            echo "  ⚠️  $alert"
        done
        return 1
    else
        echo "✅ Disk space usage is normal"
        return 0
    fi
}

# Main execution
case "${1:-monitor}" in
    "monitor")
        monitor_log_sizes
        log_result=$?
        monitor_disk_space
        disk_result=$?
        exit $((log_result + disk_result))
        ;;
    "sizes")
        monitor_log_sizes
        ;;
    "disk")
        monitor_disk_space
        ;;
    "cleanup")
        echo "Cleaning up old logs..."
        find "${LOG_DIRS[@]}" -name "*.log.*.gz" -mtime +30 -delete 2>/dev/null || true
        find "${LOG_DIRS[@]}" -name "*.log.[0-9]*" -mtime +7 -delete 2>/dev/null || true
        echo "Cleanup completed"
        ;;
    *)
        echo "Usage: $0 [monitor|sizes|disk|cleanup]"
        exit 1
        ;;
esac
EOF
    
    chmod +x "$monitor_script"
    [ "$debug" = true ] && success "Log monitoring script created: $monitor_script"
    
    return 0
}

# =============================================================================
# MANUAL LOG OPERATIONS
# =============================================================================

# Rotate logs immediately
rotate_logs_now() {
    local force=${1:-false}
    local debug=${2:-false}
    
    [ "$debug" = true ] && log "Rotating logs now..."
    
    if [ ! -f "$LOGROTATE_CONFIG" ]; then
        error "Logrotate configuration not found. Run setup_log_rotation first."
        return 1
    fi
    
    local logrotate_cmd="logrotate"
    [ "$force" = true ] && logrotate_cmd="logrotate -f"
    
    if [ "$debug" = true ]; then
        logrotate_cmd="$logrotate_cmd -v"
    fi
    
    log "Executing: $logrotate_cmd $LOGROTATE_CONFIG"
    
    if $logrotate_cmd "$LOGROTATE_CONFIG"; then
        success "Log rotation completed successfully"
        
        # Show rotation results
        [ "$debug" = true ] && {
            log "Checking rotated logs..."
            for log_dir in "${DEFAULT_LOG_DIRS[@]}"; do
                if [ -d "$log_dir" ]; then
                    echo "Rotated logs in $log_dir:"
                    find "$log_dir" -name "*.log.*" -mtime -1 2>/dev/null | head -5
                fi
            done
        }
        
        return 0
    else
        error "Log rotation failed"
        return 1
    fi
}

# Cleanup old logs
cleanup_old_logs() {
    local days_old="${1:-30}"
    local debug=${2:-false}
    
    [ "$debug" = true ] && log "Cleaning up logs older than $days_old days..."
    
    local cleanup_count=0
    local total_size=0
    
    for log_dir in "${DEFAULT_LOG_DIRS[@]}"; do
        if [ -d "$log_dir" ]; then
            [ "$debug" = true ] && log "Checking directory: $log_dir"
            
            # Find and remove compressed log files
            local old_logs=$(find "$log_dir" -name "*.log.*.gz" -mtime +$days_old 2>/dev/null)
            local old_numbered=$(find "$log_dir" -name "*.log.[0-9]*" -mtime +$days_old 2>/dev/null)
            
            for old_log in $old_logs $old_numbered; do
                if [ -f "$old_log" ]; then
                    local size=$(stat -c%s "$old_log" 2>/dev/null || echo "0")
                    total_size=$((total_size + size))
                    cleanup_count=$((cleanup_count + 1))
                    
                    [ "$debug" = true ] && log "Removing: $old_log"
                    rm -f "$old_log"
                fi
            done
        fi
    done
    
    if [ $cleanup_count -gt 0 ]; then
        local size_mb=$((total_size / 1024 / 1024))
        success "Cleaned up $cleanup_count old log files (${size_mb}MB freed)"
    else
        log "No old log files found for cleanup"
    fi
    
    return 0
}

# Monitor log sizes
monitor_log_sizes() {
    local alert_threshold="${1:-80}"  # MB
    local debug=${2:-false}
    
    [ "$debug" = true ] && log "Monitoring log sizes (alert threshold: ${alert_threshold}MB)..."
    
    local large_logs=()
    local total_size=0
    
    for log_dir in "${DEFAULT_LOG_DIRS[@]}"; do
        if [ -d "$log_dir" ]; then
            while IFS= read -r -d '' log_file; do
                if [ -f "$log_file" ]; then
                    local size_bytes=$(stat -c%s "$log_file" 2>/dev/null || echo "0")
                    local size_mb=$((size_bytes / 1024 / 1024))
                    total_size=$((total_size + size_mb))
                    
                    if [ $size_mb -gt $alert_threshold ]; then
                        large_logs+=("$log_file (${size_mb}MB)")
                    fi
                    
                    [ "$debug" = true ] && log "  $log_file: ${size_mb}MB"
                fi
            done < <(find "$log_dir" -name "*.log" -print0 2>/dev/null)
        fi
    done
    
    log "Total log size: ${total_size}MB"
    
    if [ ${#large_logs[@]} -gt 0 ]; then
        warning "Large log files detected:"
        for large_log in "${large_logs[@]}"; do
            warning "  - $large_log"
        done
        
        echo ""
        echo "Consider running log rotation:"
        echo "  $0 rotate-now"
        
        return 1
    else
        success "All log files are within acceptable size limits"
        return 0
    fi
}

# =============================================================================
# EXPORT FUNCTIONS
# =============================================================================

export -f setup_log_rotation
export -f configure_logrotate
export -f rotate_logs_now
export -f cleanup_old_logs
export -f monitor_log_sizes
export -f setup_log_rotation_cron
export -f create_log_monitor_script

# =============================================================================
# COMMAND LINE INTERFACE
# =============================================================================

# If script is run directly, provide CLI interface
if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
    case "${1:-}" in
        "setup")
            setup_log_rotation "${2:-$DEFAULT_MAX_SIZE}" "${3:-$DEFAULT_ROTATE_COUNT}" "${4:-$DEFAULT_COMPRESS_AFTER}" true
            ;;
        "rotate-now")
            rotate_logs_now "${2:-false}" true
            ;;
        "cleanup")
            cleanup_old_logs "${2:-30}" true
            ;;
        "monitor")
            monitor_log_sizes "${2:-80}" true
            ;;
        "status")
            echo "Log Rotation Status:"
            echo "==================="
            echo ""
            if [ -f "$LOGROTATE_CONFIG" ]; then
                echo "✅ Logrotate configuration: $LOGROTATE_CONFIG"
            else
                echo "❌ Logrotate configuration not found"
            fi
            
            if crontab -l 2>/dev/null | grep -q "vpn-log-check"; then
                echo "✅ Cron job configured"
            else
                echo "❌ Cron job not configured"
            fi
            
            if [ -f "/usr/local/bin/vpn-log-monitor" ]; then
                echo "✅ Log monitor script installed"
            else
                echo "❌ Log monitor script not found"
            fi
            
            echo ""
            echo "Recent log rotation activity:"
            if [ -f "/var/log/vpn-log-rotation.log" ]; then
                tail -5 /var/log/vpn-log-rotation.log
            else
                echo "No rotation log found"
            fi
            ;;
        *)
            echo "Usage: $0 {setup|rotate-now|cleanup|monitor|status}"
            echo ""
            echo "Commands:"
            echo "  setup [max_size] [count] [compress_after] - Setup log rotation"
            echo "  rotate-now [force]                        - Rotate logs immediately"
            echo "  cleanup [days]                           - Remove old logs"
            echo "  monitor [threshold_mb]                   - Check log sizes"
            echo "  status                                   - Show rotation status"
            echo ""
            echo "Examples:"
            echo "  $0 setup 100M 7 1         # 100MB max, keep 7, compress after 1"
            echo "  $0 rotate-now true        # Force rotation now"
            echo "  $0 cleanup 30             # Remove logs older than 30 days"
            echo "  $0 monitor 80             # Alert on logs > 80MB"
            exit 1
            ;;
    esac
fi